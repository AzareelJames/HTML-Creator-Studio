/*
  EngineScript created by AzareelJames.
  fincBuiltinFunctions was generated by ChatGPT.
  GitHub account: https://github.com/AzareelJames/

  Created in 2025.
*/

"use strict";

// This function was generated by ChatGPT.

function findBuiltinFunctions(input) {
  // Code by AzareelJames v

  globalThis.import = undefined;
  globalThis.findBuiltinFunctions = undefined;
  globalThis.export = undefined;
  
  input = String(input)
  .replaceAll("constructor", "")
  .replaceAll("battery", "")
  .replaceAll("EGS_ERR", "")
  .replaceAll("EGS_CANTEXEC", "")
  .replaceAll("onclick", "")
  .replaceAll("onload", "")
  .replaceAll("onclose", "")
  .replaceAll("currentOS", "");

  // Code by AzareelJames ^

  // Remove all string literals first (single, double, template)
  const noStrings = input.replace(/(["'`])(?:\\.|(?!\1).)*\1/g, "");

  // Regex: identifiers with optional .property
  const regex = /\b([a-zA-Z_$][\w$]*(?:\.[a-zA-Z_$][\w$]*)*)/g;

  let match;
  const results = new Set();

  while ((match = regex.exec(noStrings)) !== null) {
    const fullName = match[1];
    const parts = fullName.split(".");

    // Walk down globalThis
    let obj = globalThis;
    let exists = true;

    for (let p of parts) {
      if (!(p in obj)) {
        exists = false;
        break;
      }
      obj = obj[p];
    }

    if (exists) {
      results.add(fullName);
    }
  }

  return [...results];
}



// EngineScript built-in functions

const term = {
  "msg": console.log,
  "clr": console.clear,
  "er": console.error,
  "war": console.warn,
  "throw": e => {throw e},
  "info": console.info
};

Object.freeze(term);

const website = {
  "title": document.title,
  "close": window.close,
  "HTML": document.documentElement.outerHTML,
  "open": (url) => {window.open(url); setTimeout(() => {if(!document.hidden) term.er("Popup Blocked. Please disable it.")}, 1)},
  "ask": (Prompt) => window.prompt(Prompt),
  "msg": (msg) => window.alert(msg),
  "url": window.location.href,
  "back": () => {window.history.back()},
  "forward": () => {window.history.forward()},
  "reload": () => {window.location.reload()},
  "body": document.body,
  "head": document.head,
  "ok": (msg) => window.confirm(msg),
  "getIsOnline": () => {return navigator.onLine},
  "WebSocket": window.WebSocket,
  "userAgent": navigator.userAgent,
  "getHidden": () => document.hidden,
  "path": window.location.pathname,
  "getElement": {
    "byId": x => document.getElementById(x),
    "byClassName": x => document.getElementsByClassName(x),
    "byName": x => document.getElementsByName(x),
    "byTagName": x => document.getElementsByTagName(x),
    "byTagNameNS": x => document.getElementsByTagNameNS(x)
  },
  "createElement": x => document.createElement(x),
  "createElementNS": x => document.createElementNS(x),
  "selector": x => document.querySelector,
  "selectorAll": x => document.querySelectorAll
}

Object.freeze(website);


const Arithmetic = {
  "PI": Math.PI,
  "E": Math.E,
  "root": (x, y=2) => x ** (1/y),
  "complexRoot": (x, y=2) => {
    if(isNaN(Arithmetic.root(x, y)) && (!isNaN(x)) && (isFinite(x))){
      return `${Arithmetic.root(Math.abs(x), y)}i`; // Is a String, not a number.
    } else{
      return Arithmetic.root(x, y);
    }
  },
  "log": (x, b=10) => Math.log(x) / Math.log(b),
  "sin": Math.sin,
  "cos": Math.cos,
  "tan": Math.tan,
  "asin": Math.asin,
  "acos": Math.acos,
  "atan": Math.atan,
  "deg": x => x*180/Math.PI,
  "rad": x => x*Math.PI/180,
  "rand": (x=null, y=null) => {
    if(x === null || y === null){
      return Math.random();
    }

    return Math.floor(Math.random() * (y - x) + x);
  },
  "factorial": (x) => {
    if(x < 0){
      // The reason because (-1)! Is 0!/0 = 1/0
      // The even negatives are -Infinity because
      // (-2)! Is Infinity/(-1) = -Infinity
      // And the odd negatives are Infinity.

      if(x%2 === 0){
        return -Infinity;
      }

      return Infinity;
    }

    x = Number(x);
    let result = 1;

    for(let i=1; i<=x; i++){
      result *= i;
    }

    return result;
  },
  "abs": Math.abs,
  "floor": Math.floor,
  "round": Math.round,
  "ceil": Math.ceil,
  "max": Math.max,
  "min": Math.min,
  "calc": (e) => {
    if(/^[0-9+\-*/()]*$/.test(e)){
      return eval(e);
    }

    return NaN;
  },

  "limit": (f, x, delta=1e-10) => {return f(x + delta)},

  "sum": (assign=0, to, f=x => x) => {
    let x = assign;
    let result = 0;

    for(let i=0; i<to; i++){
      result += f(x);
      x++;
    }

    return result;
  },
  "opposite": x => -x,
  "randChoice": (ary=[]) => {return ary[Arithmetic.rand(0, ary.length)]},
  "pow": Math.pow
};

Object.freeze(Arithmetic);

const Obj = Object;

function assignGlobalVar(declareType, variable, value){
  if(declareType === "const"){
    Obj.defineProperty(globalThis, variable, {
      value: value,
      writable: false,
      configurable: false
    });

    return;
  }

  if(declareType === "var"){
    Obj.defineProperty(globalThis, variable, {
      value: value,
      writable: true,
      configurable: true
    });
    return;
  }

  term.er(`Unknown declare type: ${declareType}`);
}

// Battery API

if("getBattery" in navigator){
  navigator.getBattery().then((Battery) => {
    assignGlobalVar("const", "battery", 
      {
      "getLevel": () => {
        return Battery.level * 100;
      },
      "isCharging": () => {
        return Battery.charging;
      },
      "supported": true
    }
    );
  });
}
else {
  assignGlobalVar("const", "battery", {
    "supported": false
  });
}

// Person Class

class Person{
  static numberOfPersons = 0;

  constructor(name=`Person #${Person.numberOfPersons + 1}`, age=1){
    Person.numberOfPersons += 1;

    name = name.trim();

    if((age <= 0) || ((typeof age) === Number)){
      throw TypeError(`Age of ${name} Cannot be ${age}.`);
    }

    this.name = name;
    this.age = age;
    this.alive = true;

    const ageLifespan = Arithmetic.rand(85, 113);

    const loop = setInterval(() => {
      this.age += 1/60;

      if(this.age >= ageLifespan){
        this.die();
        clearInterval(loop);
      }

      if(!this.alive) clearInterval(loop);

    }, 60);
  }

  die(){
    console.info(`${this.name} Died at ${this.age}`);
    this.alive = false;
    Person.numberOfPersons -= 1;
  }

  say(msg){
    if(this.alive){
      console.log(`[${this.name}]: ${msg}`);
    } else{
      term.er(`${this.name} is already dead at ${this.age}`);
    }
  }
}

const wait = setTimeout;
const waitAndLoop = setInterval;

const clearWait = clearTimeout;
const clearWaitAndLoop = clearInterval;

const time = {
  "getTime": () => {return new Date().getTime()},
  "getDate": () => {return new Date().getDate()},
  "getTimeString": () => {return new Date().toLocaleTimeString()},
  "getDateString": () => {return new Date().toLocaleDateString()},
  "getLocaleString": () => {return new Date().toLocaleString()},

  "getYear": () => {return new Date().getFullYear()},
  "getMonth": () => {return new Date().getMonth()},
  "getDay": () => {return new Date().getDay()},
  "getHours": () => {return new Date().getHours()},
  "getMinutes": () => {return new Date().getMinutes()},
  "getSeconds": () => {return new Date().getSeconds()},
  "getMilliseconds": () => {return new Date().getMilliseconds()}
};

Object.freeze(time);

const clipboard = navigator.clipboard;

const storage = {
  "session": sessionStorage,
  "local": localStorage,
  "clearAll": () => {localStorage.clear(); sessionStorage.clear()}
}

Object.freeze(storage);

const Str = String;
const Num = Number;
const Bool = Boolean;
const Sym = Symbol;
const bigInt = BigInt;
const Pro = Promise;
const Ary = Array;
const getResponse = fetch;
const toBinary = (N) => Num(N).toString(2);
const toDecimal = (B) => parseInt(Num(B), 2);
const isInfinite = (x) => !isFinite(x);
const isNum = (x) => !isNaN(x);
const isUndefined = (x) => x === undefined;
const isNull = (x) => x === null;
const Json = JSON;
const XHR = XMLHttpRequest;
const parseInteger = parseInt;
const parseFlt = parseFloat;
const Inf = Infinity;
const nan = NaN;
const SET = Set;
const Sound = Audio;
const WebAddress = URL;
const Undefined = undefined;
const Null = null;
const len = (txt) => (txt).length;
const Zero = 0;
const Finite = Num.MAX_VALUE;
const FiniteSafeInteger = Num.MAX_SAFE_INTEGER;
const Func = Function;
const Pluger = Worker;

async function numOfBytes(data){
  const res = await getResponse(data);
  const dataBytes = await res.bytes();

  return len(dataBytes);
}

async function bytesOfData(data) {
  const res = await getResponse(data);
  const dataBytes = await res.bytes();

  return dataBytes;
}

const sleep = (ms) => {
  return new Pro((resolve) => wait(resolve, ms));
}

// Dec (Decimal) class

class Dec{
  constructor(number){
    if(number%1 === 0) number += 0.000000000000001;

    this.num = number;
    return this.num;
  }
}


try{
  Obj.defineProperty(globalThis, "__AUDIO_CONTEXT__", {
    value: new AudioContext,
    writable: false,
    configurable: false
  });

} catch{
  term.er("EGS_NotSupported: This Browser doesn't support AudioContext. now playHertz() function is unusable.");
}

function playHertz(hertz, seconds=0.1){
  const o = __AUDIO_CONTEXT__.createOscillator();
  o.frequency.value = hertz;
  o.connect(__AUDIO_CONTEXT__.destination);
  o.start();
  o.stop(__AUDIO_CONTEXT__.currentTime + seconds);
}

const toHertz = (M) => 440*2**((M - 69)/12);
const toMIDI = (n) => 440 * 2**((n-69)/12);

function createError(er){
  if(findBuiltinFunctions(Str(er) + "()").length !== 0){
    throw new
    TypeError(`EGS_CANTCREATE_ER: Cannot create Error "${er}" because is a JavaScript Built-in Function.`);
  }

  eval(
    `
    globalThis.${er} =
    class ${er} extends Error{
      constructor(msg){
        super(msg);
        this.name = "${er}";
      }
    }
    `
  );
}

const Const = {
  "CONST": "const",
  "VAR": "var",
  "OBJECT": "object",
  "STRING": "string",
  "BIGINT": "bigint",
  "BOOLEAN": "boolean",
  "FUNCTION": "function",
  "NUMBER": "number",
  "SYMBOL": "symbol",
  "UNDEFINED": "undefined",
  "NULL": "null",
  "PERSON": "person",
  "PROMISE": "promise"
};

Obj.freeze(Const);

const kill = () => {term.war("kill() may not work in try block."); throw "[Program Stopped by kill()]"};

for(let OS of ["Win", "Mac", "Linux", "Android", "iOS", "CrOS"]){
  if(website.userAgent.indexOf(OS) !== -1){
    assignGlobalVar(Const.CONST, "currentOS", OS);
    break;
  }
}

// getExtension

async function getExtension(extension){
  try{
    const res = await getResponse(`EGSF/${extension}.js`);
    const txt = await res.text();
    return eval(txt);
  }
  catch{
    term.er(`Extension not found: ${extension}`);
  }
}

function repeat(count=0, callback=() => {}){
  for(let __COUNT__=1; __COUNT__<=count; __COUNT__++){
    callback();
  }
}

// HTML Class

class HTML{
  constructor(){
    this.x = document.createElement("div");
    this.x.style.border = "3px solid gray";

    website.body.appendChild(this.x);
  }

  HTML(html){
    this.x.innerHTML = html;
  }

  style(style){
    this.x.style = style;
  }

  id(id){
    this.x.id = id;
  }

  className(cN){
    this.x.className = cN;
  }

  classList(cL){
    this.x.classList(cL);
  }

}


function tried(callback=() => {}){
  try{
    callback();
  } catch{
    return;
  }
};

// EGS Errors

createError("EGS_ERR");
createError("EGS_CANTEXEC");

// Execute functions

export function EGS_Exec(code){

  if(findBuiltinFunctions(code).length !== 0){
      throw new 
      EGS_CANTEXEC(`JavaScript Built-in/s is not allowed in this script: ${findBuiltinFunctions(code)}`);
  }

  try{
      eval(`${code};\nif((typeof main) === "function") main();`); // after code executes, main always be executed
  } catch(E){
      throw new EGS_ERR(
  `Cannot procceed to the next line.
  ERR_MSG: ${E}
  STACK_MSG: ${E.stack}
  If is still not working, please report to https://github.com/AzareelJames/ and share your script.
  `
  )
  }
}

export async function EGS_ExecFile(file){
  const res = await fetch(file);

  if(!res.ok) throw Error(`${file} Is not found ERR_CODE: ${code.status}`);

  const code = await res.text();

  EGS_Exec(code);

}

